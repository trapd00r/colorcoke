#!/usr/bin/perl
our $APP     = 'colorcoke';
our $VERSION = '0.3.5';

use strict;
use feature 'say';
use Getopt::Long;
use Pod::Usage;

my $DEBUG = 0;

our($opt_r_step, $opt_g_step, $opt_b_step) = (10) x 3;
our $opt_hex            = '000000';
our $opt_starting_point = 17;  # Start from 17
our $opt_endpoint       = 231; # End at 231
our $opt_ansi_only      = 0;
our $opt_random         = 0;
our $opt_random_r       = 256;
our $opt_random_g       = 256;
our $opt_random_b       = 256;
our $opt_single_hex     = 0;
our @opt_single_color   = ();
our @opt_do_not_modify  = (3,232);

if(!@ARGV) {
  say "$APP $VERSION\n";
  pod2usage(verbose => 1);
}

GetOptions(
  'c|color:s'       => \$opt_hex,
  'r|red:i'         => \$opt_r_step,
  'g|green:i'       => \$opt_g_step,
  'b|blue:i'        => \$opt_b_step,
  '1|single:s{2}'   => \@opt_single_color,
  's|start:i'       => \$opt_starting_point,
  'end:i'           => \$opt_endpoint,
  'ansi'            => \$opt_ansi_only,
  'random'          => \$opt_random,
  'rr|rand-red:i'   => \$opt_random_r,
  'rg|rand-green:i' => \$opt_random_g,
  'rb|rand-blue:i'  => \$opt_random_b,
  'no:i{1,}'        => \@opt_do_not_modify,
  'h|help'          => sub { say "$APP $VERSION\n"; pod2usage(verbose => 1) },
  'man'             => sub { pod2usage(verbose => 3) and exit(0) },
  'debug'           => \$DEBUG,
);

say "\e[38;5;160mR\e[0m Step: $opt_r_step";
say "\e[38;5;148mG\e[0m Step: $opt_g_step";
say "\e[38;5;33mB\e[0m Step: $opt_b_step";
say "ANSI: $opt_starting_point";
say " END: $opt_endpoint";

if(scalar(@opt_single_color) == 2) {
  set_single_color(@opt_single_color);
  exit(0);
}

set_shade(make_shade());

sub set_single_color {
  my $rgb   = shift;
  my $index = shift;
  my($r,$g,$b) = getrgb($rgb);
  printf("\e]4;$index;rgb:$r/$g/$b\e\\");
  say;
  printf("\e[38;5;$index%s   $index  \e[0m", 'm');
}
sub getrgb {
  my $hex = shift;
  my ($r,$g,$b) = $hex =~ /(..)(..)(..)/;
  ($r,$g,$b) = (hex($r), hex($g), hex($b));
  print "$r | $g | $b\n";
  return($r,$g,$b);
}

sub set_shade {
  my @colors = @_;

  my $i = $opt_starting_point;

  for my $color(@colors) {
    unless($i ~~ @opt_do_not_modify) {
      my ($r, $g, $b) = $color =~ /(..)(..)(..)/;
      printf("\e]4;$i;rgb:$r/$g/$b\e\\");
      #printf("\e]10;rgb:$r/$g/$b\007");
      printf("\e[38;5;$i%s$i\e[0mÂ·", 'm');
    }

    $i++;
  }
  say;
}

sub make_shade {
  my @tint = ();
  my ($r, $g, $b) = $opt_hex =~ /(..)(..)(..)/; #FIXME

  $r = hex($r);
  $g = hex($g);
  $b = hex($b);

  $opt_starting_point = 0   if($opt_starting_point == 1); # Include ANSI
  $opt_endpoint       = 255 if($opt_endpoint == 1);       # Include greyscale


  if($opt_ansi_only) {
    $opt_starting_point = 0;
    $opt_endpoint       = 16;
  }

  for ($opt_starting_point .. $opt_endpoint) {

    if($opt_random) {

      $r = int(rand($opt_random_r) % 256);
      $g = int(rand($opt_random_g) % 256);
      $b = int(rand($opt_random_b) % 256);

      do {
        say "\e[1mRand R\e[0m: $r";
        say "\e[1mRand G\e[0m: $g";
        say "\e[1mRand B\e[0m: $b";
      } if ($DEBUG);

    }

    $r = (($r + $opt_r_step) < (256 - ($opt_r_step + $r)))
      ? ($r + $opt_r_step)
      : ($r + $opt_r_step)
      #: (256 - ($opt_r_step))
      ;

    $g = (($g + $opt_g_step) < (256 - ($opt_g_step + $g)))
      ? ($g + $opt_g_step)
      : ($g + $opt_g_step)
      #: (256 - ($opt_g_step))
      ;

    $b = (($b + $opt_b_step) < (256 - ($opt_b_step + $b)))
      ? ($b + $opt_b_step)
      : ($b + $opt_b_step)
      #: (256 - ($opt_b_step))
      ;

      #$opt_r_step++ if($opt_random);
      #$opt_g_step++ if($opt_random);
      #$opt_b_step++ if($opt_random);
    my $hex_r = sprintf("%02x", $r);
    my $hex_g = sprintf("%02x", $g);
    my $hex_b = sprintf("%02x", $b);

    do {
      say "\e[1m$hex_r$hex_g$hex_b\e[0m";
      say "\e[38;5;160m0xR\e[0m: $hex_r";
      say "\e[38;5;148m0xG\e[0m: $hex_g";
      say "\e[38;5;033m0xB\e[0m: $hex_b";
    } if($DEBUG);

    push(@tint, $hex_r . $hex_g . $hex_b);

  }
  return(@tint);
}

=pod

=head1 NAME

  colorcoke - modify the extended, non-ANSI terminal colorset

=head1 DESCRIPTION

  colorcoke lets one modify the extended colorset (88-16 or 256-16 colors,
  respectively) for a running terminal session. The change takes effect
  immediately - no need to restart the terminal, like when using xrdb.

  Shades and tints can be generated for an arbitary number of ranges.

  The ANSI colors can be left untouched, be included in a shade or set
  separately. One can also exclude everything but the ANSI colors.
  The ANSI colors is untouched by default.

  The grey scale ramp (extended color index 232-255) is left untouched by
  default. To include them, set the end point to 255.

  The starting point of a shade is specified with the -h flag, and the stepping
  is controlled with the -r, -g and -b flag - red, green and blue channel.

=head1 OPTIONS

  -c,   --color       the color which will start the shade
  -r,   --red         red channel stepping
  -g,   --green       green channel stepping
  -b,   --blue        blue channel stepping
  -s,   --start       first color index to operate on (default: 17)
  -e,   --end         last  color index to operate on (default: 231)
  -a,   --ansi        modify the ANSI color range only
  -1,   --single      set a single color (HEX, index)
        --random      randomize the colors
  -rr,  --rand-red    control amount of red
  -rb,  --rand-blue   control amount of blue
  -rg,  --rand-green  control amount of green
  -n,   --no          do not modify color n

  -h,   --help        show the help and exit
  -m,   --man         show the manpage and exit

=head1 AUTHOR

Written by Magnus Woldrich

=head1 COPYRIGHT

Copyright (C) 2010 Magnus Woldrich

Licence GPLv2

=cut
